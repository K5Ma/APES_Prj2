/*
    FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
    All rights reserved

    VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.

    This file is part of the FreeRTOS distribution.

    FreeRTOS is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License (version 2) as published by the
    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.

    ***************************************************************************
    >>!   NOTE: The modification to the GPL is included to allow you to     !<<
    >>!   distribute a combined work that includes FreeRTOS without being   !<<
    >>!   obliged to provide the source code for proprietary components     !<<
    >>!   outside of the FreeRTOS kernel.                                   !<<
    ***************************************************************************

    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE.  Full license text is available on the following
    link: http://www.freertos.org/a00114.html

    ***************************************************************************
     *                                                                       *
     *    FreeRTOS provides completely free yet professionally developed,    *
     *    robust, strictly quality controlled, supported, and cross          *
     *    platform software that is more than just the market leader, it     *
     *    is the industry's de facto standard.                               *
     *                                                                       *
     *    Help yourself get started quickly while simultaneously helping     *
     *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     *    tutorial book, reference manual, or both:                          *
     *    http://www.FreeRTOS.org/Documentation                              *
     *                                                                       *
    ***************************************************************************

    http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
    the FAQ page "My application does not run, what could be wrong?".  Have you
    defined configASSERT()?

    http://www.FreeRTOS.org/support - In return for receiving this top quality
    embedded software for free we request you assist our global community by
    participating in the support forum.

    http://www.FreeRTOS.org/training - Investing in training allows your team to
    be as productive as possible as early as possible.  Now you can receive
    FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
    Ltd, and the world's leading authority on the world's leading RTOS.

    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
    compatible FAT file system, and our tiny thread aware UDP/IP stack.

    http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
    Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.

    http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
    Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
    licenses offer ticketed support, indemnification and commercial middleware.

    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
    engineered and independently SIL3 certified version for use in safety and
    mission critical applications that require provable dependability.

    1 tab == 4 spaces!
*/

#ifndef FREERTOS_CONFIG_H
#define FREERTOS_CONFIG_H

/*-----------------------------------------------------------
 * Application specific definitions.
 *
 * These definitions should be adjusted for your particular hardware and
 * application requirements.
 *
 * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
 * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
 *
 * See http://www.freertos.org/a00110.html.
 *----------------------------------------------------------*/

#include "Global_Defines.h"

#define configCPU_CLOCK_HZ              SYSTEM_CLOCK
#define configUSE_TICKLESS_IDLE         0
#define configTICK_RATE_HZ              ( ( TickType_t ) 1000 )

#define configUSE_PREEMPTION            1
#define configUSE_IDLE_HOOK             0
#define configUSE_TICK_HOOK             0
#define configMAX_PRIORITIES            ( 5 )
#define configMINIMAL_STACK_SIZE        ( ( unsigned short ) 100 )
#define configTOTAL_HEAP_SIZE           ( ( size_t ) ( 50000 ) )
#define configMAX_TASK_NAME_LEN         ( 10 )
#define configUSE_TRACE_FACILITY        1
#define configUSE_16_BIT_TICKS          0
#define configIDLE_SHOULD_YIELD         1
#define configUSE_MUTEXES               1
#define configQUEUE_REGISTRY_SIZE       10
#define configCHECK_FOR_STACK_OVERFLOW  2
#define configUSE_RECURSIVE_MUTEXES     1
#define configUSE_MALLOC_FAILED_HOOK    0
#define configUSE_APPLICATION_TASK_TAG  0
#define configUSE_COUNTING_SEMAPHORES   1

/* Co-routine definitions. */
#define configUSE_CO_ROUTINES           0
#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )

/* Software timer definitions. */
#define configUSE_TIMERS                1
#define configTIMER_TASK_PRIORITY       ( configMAX_PRIORITIES - 1 )
#define configTIMER_QUEUE_LENGTH        5
#define configTIMER_TASK_STACK_DEPTH    ( configMINIMAL_STACK_SIZE * 2 )

/* Set the following definitions to 1 to include the API function, or zero
to exclude the API function. */
#define INCLUDE_vTaskPrioritySet		1
#define INCLUDE_uxTaskPriorityGet       1
#define INCLUDE_vTaskDelete             1
#define INCLUDE_vTaskCleanUpResources   1
#define INCLUDE_vTaskSuspend            1
#define INCLUDE_vTaskDelayUntil         1
#define INCLUDE_vTaskDelay              1
#define INCLUDE_xTaskGetHandle			1
//#define INCLUDE_uxTaskGetStackHighWaterMark    1


/* The highest interrupt priority that can be used by any interrupt service
routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
PRIORITY THAN THIS! (higher priorities are lower numeric values. */
#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    10

/* Interrupt priorities used by the kernel port layer itself.  These are generic
to all Cortex-M ports, and do not rely on any particular library functions. */
#define configKERNEL_INTERRUPT_PRIORITY         ( 7 << 5 )    /* Priority 7, or 0xE0 as only the top three bits are implemented.  This is the lowest priority. */
#define configMAX_SYSCALL_INTERRUPT_PRIORITY     ( 5 << 5 )  /* Priority 5, or 0xA0 as only the top three bits are implemented. */


/* The configPRE_SLEEP_PROCESSING() and configPOST_SLEEP_PROCESSING() macros
allow the application writer to add additional code before and after the MCU is
placed into the low power state respectively.  The empty implementations
provided in this demo can be extended to save even more power. */
void vPreSleepProcessing( unsigned long xExpectedIdleTime );
void vPostSleepProcessing( unsigned long xExpectedIdleTime );
#define configPRE_SLEEP_PROCESSING( xExpectedIdleTime ) vPreSleepProcessing( xExpectedIdleTime );
#define configPOST_SLEEP_PROCESSING( xExpectedIdleTime ) vPostSleepProcessing( xExpectedIdleTime );

/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
standard names. */
//#define vPortSVCHandler SVC_Handler
//#define xPortPendSVHandler PendSV_Handler
//#define xPortSysTickHandler SysTick_Handler


#endif /* FREERTOS_CONFIG_H */

/*
 * AESD (APES) Project 2
 *
 * By Khalid AlAwadhi - Spring 2019
 *
 * Uses FreeRTOS 9.0, additionally all the driver source files were updated to 2.1.4.178
 *
 * This base project was gotten from GitHub:
 * https://github.com/akobyl/TM4C129_FreeRTOS_Demo
 *
 */
//Standard includes
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>

//TivaWare includes
#include "driverlib/sysctl.h"
#include "driverlib/debug.h"
#include "drivers/pinout.h"
#include "driverlib/interrupt.h"

//FreeRTOS includes
#include "FreeRTOSConfig.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

//My includes
#include "Global_Defines.h"
#include "Master_Functions.h"
#include "My_UART.h"
#include "BME280Task.h"
#include "BBComm_Task.h"
#include "NFC_Task.h"
#include "KeypadEpaper_Task.h"
#include "LoadCell_Task.h"
#include "Outputs_Task.h"


/* Global Variables */
QueueHandle_t xQueue_TXStruct = NULL;				//This is the queue the BB_Comm Task will read from and other tasks will send to
char Start_RX[1] = "0";								//Will store the start CMD coming in from BB
volatile bool POLL_RX = false;						//Flag used to know if we are currently RXing from BB or not
QueueHandle_t xQueue_KEStruct = NULL;				//This is the queue the will get any KE structs from BB
QueueHandle_t xQueue_LCStruct = NULL;				//This is the queue the will get any LC structs from BB
QueueHandle_t xQueue_OIStruct = NULL;				//This is the queue the will get any OI structs from BB



/*
 * ++++++++++ TO-DO: ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * 1- [COMPLETED] CLEAN PROJECT FROM HW5 CODE
 *
 * 2- [COMPLETED] TEST UART TX IN ANOTHER PROJECT
 *				L-> Created My_UART.h/.c
 *
 * 3- [COMPLETED] ADD ALL AVAILABLE UARTS SUPPORT IN My_UART.h/.c
 *				L-> ALL PINs SUPPORT WAS ADDED (NOTE THAT SOME PINS HAVE AN ADDITIONAL TX OR RX PIN, HOWEVER, I
 *				    ONLY ADDED ONE OF THEM AS I DON'T THINK WE WILL NEED TO TX/RX FROM TWO SOURCES.
 *
 * 4- [COMPLETED!!! - THEY ALL WORK] TEST ALL NEWLY ADDED UARTS AND MAKE SURE TX WORKS FROM ALL
 *
 * 5- [COMPLETED!!!] WORK ON RX => BB_Comm_Task(): RECIEVE TEST STRUCTURE FROM BB AND DECODE PROPERLY
 *
 * 6- [COMPLETED] THINK ABOUT HOW MSGS WILL BE STORED AND TRANSMITTED (CIRC BUFF AND UART? CIRC BUFF WOULD BE SENT TO BB AND
 * 		 		|  UART IS JUST LOCAL ECHO)
 * 		 		L-> TALKED TO PROF. RICK ABOUT IT AND HE RECOMMENDED I USE THE XQUEUE AS IT HANDLES MORE STUFF IN THE
 * 		 			BACKGROUND. ADDITIONALY, HE RECOMENDED JUST COPYING THE MSG STRUCT TO THE QUEUE (WHICH XQUEUE DOES
 * 		 			ALREADY) AS OPPOSED TO MALLOC'ING (TO AVOID MEMORY LEAKS AND OTHER ISSUES)
 *
 * 7- [COMPLETED] ADD CIRC BUFF LIB
 * 				L-> ADDED My_CircBuff.h/.c
 *
 * 8- [COMPLETED] CREATE TEST STRUCT
 *
 * 9- [COMPLETED] TEST STORING AND READING FROM TEST STRUCT
 *
 * 10- [COMPLETED] MAYBE DYNAMICALLY ALLOCATE STRING IN Log_UART0()? FOR NOW IT IS A STATIC SIZE
 * 				L-> DYNAMIC AVOIDS A STACK OVERFLOW ISSUE?
 *
 * 11- [] HAVE LEDs BLINK DURING SENDING FROM BB_COMM
 *
 * 12- [COMPLETED] CREATE AN XQUEUE
 * 				L-> CREATED xQueue_Msgs GLOBAL VAR USED IN BB_Comm_Task.h/.c AND Master_Functions.h/.c
 * 				    ADDITIONALLY, CREATED A MSG SENDING FUNCTION 'SendMsgToBB()' IN Master_Functions.h/.c
 *
 * 13- [COMPLETED] TEST STORING MSG TO XQUEUE
 *
 * 14- [COMPLETED] TEST READING MSG FROM XQUEUE
 *
 * 15- [COMPLETED] REMOVE MY CIRC BUFF LIB
 *
 * 16- [COMPLETED] ADD BOOT-UP MSG
 * 				L-> CREATED DisplayBootUpMsg()
 *
 * 17- [COMPLETED] CHANGE FREERTOS HEAP TYPE TO HEAP 3 OR 4
 * 				L-> USED heap_4.c
 *
 * 18- [COMPLETED] CONNECT TivaBLE MODULE
 * 				L-> TivaBLE MAC ADDRESS: 9C1D_5888_6519
 *
 * 19- [COMPLETED] HAVE RX INTERRUPPTS FOR BB_Comm TASK
 * 				L-> ALL UART PORTS CAN NOW HAVE INTERUPPTS ENABLED SIMPLY BY CALLING Init_UARTx() AND HAVING THE
 * 				    LAST PARAMETER BE TRUE. HOWEVER, YOU NEED TO DEFINE WHAT THE RX INTERUPPT WILL DO IN ITS
 * 				    SPECIFIC INTERUPPT HANDLER.
 *
 * 20- [COMPLETED] ADD TEST STRUCT (SAME AS BB SIDE)
 *
 * 21- [COMPLETED] ADD DEFINE FOR CURRENT VERSION TO UPDATE DYNAMICALLY
 * 				L-> ONLY NEED OT CHANGE THE DEFINE IN Global_Defines.h
 *
 * 22- [COMPLETED!] TEST STRUCT SIZE ON TIVA SIDE
 * 				L-> SIZE IS THE SAME AS BB SIDE => 86 BYTES!
 *
 * 23- [SCRAPPED] RX STRUCT FROM BB, MODIFY, AND THEN TX BACK TO BB
 *
 * 24- [COMPLETED] CREATE ALL THE NEEDED BASE TASKS (NFC, KEYPADEPAPER, LOADCELL, LUX AND SERVO)
 * 				L-> RESPECTIVE .h/.c FILES CREATED AND DEFINES ADDED AS WELL AS CALLS TO INIT FROM MAIN
 *
 * 25- [COMPLETED!!!] CREATE A FUNCTION THAT LOGS TO BB AS A NORMAL LOG
 * 				L-> CREATED Send_LogMsgStruct_ToBB()
 *
 * 26- [COMPLETED] CREATE UART SEND STRING FUNCTION
 *
 * 27- [] ADD METHOD TO CHECK IF BT LINK IS ALIVE
 *
 * 28- [] LOG LOCALLY IF BT LINK IS DEAD
 *
 * 29- []
 *
 *
 * +++++++++++++++++++++ CHANGES: +++++++++++++++++++++
 * -
 *
 *
 */


int main()
{
	/* Initialize system clock to 120 MHz */
	uint32_t output_clock_rate_hz = SysCtlClockFreqSet( (SYSCTL_XTAL_25MHZ | SYSCTL_OSC_MAIN | SYSCTL_USE_PLL | SYSCTL_CFG_VCO_480), SYSTEM_CLOCK);
	ASSERT(output_clock_rate_hz == SYSTEM_CLOCK);

	/* Initialize the GPIO pins for the Launchpad */
	PinoutSet(false, false);

	/* Init UART0 - Used for local debugging and msgs */
	Init_UARTx(UART0, SYSTEM_CLOCK, 9600, false);
	Log_UART0(GetCurrentTime(), T_Main, "INFO", "UART0 was init successfully!");

	/* Displays messages to UART0 */
	DisplayBootUpMsg(UART0);

	/* Enable global interrupts */
	IntMasterEnable();

	/* Init BBComm Task */
	if(BBComm_TaskInit())
	{
		Log_Msg(T_Main, "CRITICAL", "Could not init BBComm Task!", LOCAL_ONLY);
	}
	else
	{
		Log_Msg(T_Main, "INFO", "BBComm Task init successfully!", LOCAL_ONLY);
	}

	/* Init NFC Task */
	if(NFC_TaskInit())
	{
		Log_Msg(T_Main, "CRITICAL", "Could not init NFC Task!", LOCAL_ONLY);
	}
	else
	{
		Log_Msg(T_Main, "INFO", "NFC Task init successfully!", LOCAL_ONLY);
	}

	/* Init KeypadEpaper Task */
	if(KeypadEpaper_TaskInit())
	{
		Log_Msg(T_Main, "CRITICAL", "Could not init KeypadEpapaer Task!", LOCAL_ONLY);
	}
	else
	{
		Log_Msg(T_Main, "INFO", "KeypadEpapaer Task init successfully!", LOCAL_ONLY);
	}

	/* Init LoadCell Task */
	if(LoadCell_TaskInit())
	{
		Log_Msg(T_Main, "CRITICAL", "Could not init LoadCell Task!", LOCAL_ONLY);
	}
	else
	{
		Log_Msg(T_Main, "INFO", "LoadCell Task init successfully!", LOCAL_ONLY);
	}

	/* Init Outputs Task */
	if(Outputs_TaskInit())
	{
		Log_Msg(T_Main, "CRITICAL", "Could not init Outputs Task!", LOCAL_ONLY);
	}
	else
	{
		Log_Msg(T_Main, "INFO", "Outputs Task init successfully!", LOCAL_ONLY);
	}

//    if(BME_TaskInit())
//    {
//        Log_Msg(T_Main, "CRITICAL", "Could not init BME Task!", LOCAL_ONLY);
//    }
//    else
//    {
//        Log_Msg(T_Main, "INFO", "BME Task init successfully!", LOCAL_ONLY);
//    }

	vTaskStartScheduler();
	return 0;
}




/*  ASSERT() Error function
 *
 *  failed ASSERTS() from driverlib/debug.h are executed in this function
 */
void __error__(char *pcFilename, uint32_t ui32Line)
{
    // Place a breakpoint here to capture errors until logging routine is finished
    while (1)
    {
    }
}


void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
	( void ) pcTaskName;
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
	for( ;; );
}
/*
 * KeypadEpaper_Task.c
 *
 *  Created on: Apr 26, 2019
 *      Author: poorn
 */

#include "KeypadEpaper_Task.h"

// Standard Includes
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>

#include "drivers/pinout.h"
#include "utils/uartstdio.h"

// Third Party Includes
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_i2c.h"
#include "inc/hw_sysctl.h"
#include "inc/hw_types.h"
#include "inc/hw_uart.h"
#include "inc/hw_adc.h"
#include "inc/hw_pwm.h"

// TivaWare includes
#include "driverlib/sysctl.h"
#include "driverlib/debug.h"
#include "driverlib/rom.h"
#include "driverlib/interrupt.h"
#include "driverlib/i2c.h"
#include "driverlib/debug.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/uart.h"
#include "driverlib/timer.h"
#include "driverlib/fpu.h"
#include "driverlib/adc.h"
#include "driverlib/pwm.h"

//FreeRTOS includes
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

//My includes
#include "Global_Defines.h"
#include "Master_Functions.h"

/* Global Variables */
extern QueueHandle_t xQueue_KEStruct;

// Variables that will be shared between functions
uint8_t EP_Command_Array[EP_Command_Max_Length], EP_Retries;
uint8_t EP_Image_String_Counter, EP_Command_Array_Universal_Counter, EP_Response_Init;
uint16_t EP_Full_Command_Length, EP_Response_ms_Counter;
uint16_t EP_counter = 0;

char EP_FileName[20];
bool EP_StoreResp;

uint8_t KeyPad_Pos;
uint16_t KeyPad_Counter;

const char Key_LookUp[KeyPad_Rows][KeyPad_Cols] = {
                               {'1', '2', '3', 'A'},
                               {'4', '5', '6', 'B'},
                               {'7', '8', '9', 'C'},
                               {'*', '0', '#', 'D'}
};

bool EP_Update_Cmd, KeyPad_Error, EP_Error;

KE_T2B_Struct EP_Tx;			//Struct to be TXed




uint8_t KeypadEpaper_TaskInit()
{
    //Create task, if it fails return 1, else 0
    if( xTaskCreate(KeypadEpaper_Task,				/* The function that implements the task */
			   (const portCHAR *)"KeypadEpaper",	/* The text name assigned to the task - for debug only as it is not used by the kernel */
               ((configMINIMAL_STACK_SIZE) * 10),	/* The size of the stack to allocate to the task */
			   NULL,								/* The parameter passed to the task */
			   PRIORITY_KEYPADEPAPER_TASK,	 		/* The priority assigned to the task */
			   NULL)								/* The task handle is not required, so NULL is passed */
    			!= pdTRUE
      )
      {
    	return 1;
      }

	return 0;
}



void KeypadEpaper_Task(void *pvParameters)
{
	/* Delay a bit to make sure BBComm Task starts-up first */
	const TickType_t xDelay = 10 / portTICK_PERIOD_MS;
	vTaskDelay(xDelay);

	/* Create a queue capable of containing 15 structs */
	xQueue_KEStruct = xQueueCreate(15,  sizeof(KE_B2T_Struct));

	if( xQueue_KEStruct == NULL )
	{
		/* Queue was not created and must not be used. */
		Log_Msg(T_KeypadEpaper, "FATAL", "Could not create xQueue_KEStruct!", LOCAL_ONLY);
	}
	else
	{
		Log_Msg(T_KeypadEpaper, "INFO", "Created xQueue_KEStruct successfully!", LOCAL_ONLY);
	}

    EP_UART_Init();
    EP_Error = false;
    EP_Update_Cmd = false;


//    EP_Rx.KeyPad_Poll = true;

   // EP_Rx.EP_Update = false;
//    EP_Rx.EP_Update = true;
//    strncpy(EP_Rx.Image_Name, "P1.bmp", sizeof(EP_Rx.Image_Name));

    #if     EP_DEBUG_PRINTF
        Log_Msg(T_KeypadEpaper, "INFO", "Handshake", LOCAL_ONLY);
    #endif
        EP_Send_Command(EP_CMD_Handshake, EP_Handshake_Type);
        if(EP_Error == false)
        {
            #if     EP_DEBUG_PRINTF
                Log_Msg(T_KeypadEpaper, "INFO", "Startup Handshake Succeeded", LOCAL_ONLY);
            #endif
        }
        else
        {
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send KE BIST Failure LOG to BB
            #if     EP_DEBUG_PRINTF
                Log_Msg(T_KeypadEpaper, "ERROR", "Startup Handshake Failed", LOGGER_AND_LOCAL);
            #endif
        }

    #if     EP_DEBUG_PRINTF
        Log_Msg(T_KeypadEpaper, "INFO", "Storage Set", LOCAL_ONLY);
    #endif
        EP_Update_Cmd = true;
        EP_Send_Command(EP_CMD_Storage_Set, EP_Storage_Set_Type);
        if(EP_Error == false)
        {
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send KE BIST Success LOG to BB
            #if     EP_DEBUG_PRINTF
                Log_Msg(T_KeypadEpaper, "INFO", "Storage Set Succeeded", LOCAL_ONLY);
                Log_Msg(T_KeypadEpaper, "INFO", "Starting KE Normal Operation", LOGGER_AND_LOCAL);
            #endif
        }
        else
        {
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send KE BIST Failure LOG to BB
            #if     EP_DEBUG_PRINTF
                Log_Msg(T_KeypadEpaper, "ERROR", "Storage Set Failed", LOGGER_AND_LOCAL);
            #endif
        }
        EP_Update_Cmd = false;

    uint8_t i;
    char tp[50];

    KeyPad_Init();
    #if KeyPad_DEBUG_PRINTF
        Log_Msg(T_KeypadEpaper, "INFO", "KeyPad Initialized", LOCAL_ONLY);
    #endif

	/* Stores received KE_B2T_Structs */
	KE_B2T_Struct EP_Rx;

	while(1)
	{
		vTaskDelay(EP_Polling_Timems);
		EP_counter += 1;

		// Testing whether EPaper is still functional - and connected with the Controller
		// This is done by sending a handshake, and later on checking error flag
		if(EP_Error == false)
		{
			//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send KE Failure LOG to BB
			#if     EP_DEBUG_PRINTF
//		                Log_Msg(T_KeypadEpaper, "INFO", "Checking EPaper Status... Command: Handshake", LOCAL_ONLY);
		    #endif
		    EP_Send_Command(EP_CMD_Handshake, EP_Handshake_Type);
		    #if     EP_DEBUG_PRINTF
		         if(EP_Error == false)
				 {
		        	 if(EP_counter >= 50)
		        	 {
		        		 EP_counter = 0;
		        		 Log_Msg(T_KeypadEpaper, "INFO", "EPaper is Online", LOCAL_ONLY);
		        	 }
				 }
		        else
				{
                    Log_Msg(T_KeypadEpaper, "INFO", "EPaper Went Offline", LOGGER_AND_LOCAL);
				}
		    #endif
		}

		// Attempting to communicate with EPaper while supporting both
		// Limited and Infinite retry modes
		else
		{
			//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send KE Online LOG to BB
		    #if     (EP_Retry_Mode == EP_Limited)
		    if(EP_Retries != 0x00)
		    {
		          EP_Retries -= 1;
		     #endif
		        #if     EP_DEBUG_PRINTF
//		                        Log_Msg(T_KeypadEpaper, "INFO", "Retrying Connection with EPaper... Command: Handshake", LOCAL_ONLY);
		          #endif
		                    EP_UART_Init();
		                    EP_Send_Command(EP_CMD_Handshake, EP_Handshake_Type);
		                    if(EP_Error == true)
		                    {
		                        #if     EP_DEBUG_PRINTF
//		                            Log_Msg(T_KeypadEpaper, "ERROR", "Retry failed with EPaper", LOGGER_AND_LOCAL);
		                        #endif
		                    }
		                    else
		                    {
		                        #if     EP_DEBUG_PRINTF
		                            Log_Msg(T_KeypadEpaper, "INFO", "EPaper is Online now", LOGGER_AND_LOCAL);
		                        #endif
		                    }
		            #if     (EP_Retry_Mode == EP_Limited)
		    }
		            #endif
		}

		if( xQueue_KEStruct != 0 )
		{
			/* Block for 10 ticks if a message (struct buffer) is not immediately available */
			if( xQueueReceive( xQueue_KEStruct, &EP_Rx, ( TickType_t ) 100 ) )
			{
		//		Log_Msg(T_KeypadEpaper, "INFO", "Got struct from BB!", LOCAL_ONLY);

				//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Receive EP_Rx structure from BBComm Task with 100ms Timeout

				if((EP_Rx.EP_Update == true) && (EP_Error == false))
				{
					EP_StoreResp = true;
					//            strncpy(EP_Rx.Image_Name, "123.BMP", sizeof(EP_Rx.Image_Name));

					// Display image on screen, for now - always start drawing from top left corner
					EP_Display_Image(EP_Rx.Image_Name, 0, 0);

					// Update the global status/variable if possible - to prevent redisplaying
					// the same image again and again. Redisplaying must be taken care of in
					// some other way if this is not doable, since EPaper refresh cycles are
					// very limited - and redrawing uselessly will kill the display eventually
					EP_Rx.EP_Update = false;

					snprintf(tp, sizeof(tp), "Got:%s Displayed:%s", EP_Rx.Image_Name, EP_FileName);
					Log_Msg(T_KeypadEpaper, "INFO", tp, LOCAL_ONLY);


					// EPaper Update rate is slow (requires 3 seconds)
//					vTaskDelay(EP_Reset_Timems - EP_Polling_Timems);
				}

				if((EP_Rx.KeyPad_Poll == true) && (EP_Error == false))
				{
					KeyPad_Error = false;
					for(i = 0; i < KeyPad_Code_Size; i ++)      EP_Tx.KeyPad_Code[i] = 0;

					#if     (KeyPad_INDIVIDUAL_TESTING == false)
				                EP_Rx.KeyPad_Poll = false;
				            #endif
				                KeyPad_Counter = 0;
				                KeyPad_Pos = 0;

//				                taskENTER_CRITICAL();

				            #if KeyPad_DEBUG_PRINTF
				                Log_Msg(T_KeypadEpaper, "INFO", "Code Scanning Started", LOCAL_ONLY);
				            #endif

				            while(1)
				            {
				                for(i = 0; i < KeyPad_Rows; i ++)
				                {
				                    KeyPad_SelectRow(i);
				                    while(1)
				                    {
				                        if(KeyPad_ScanCode(i) == true)
				                        {
				                            #if KeyPad_DEBUG_PRINTF
//				                                Log_Msg(T_KeypadEpaper, "INFO", "Digit Stored", LOCAL_ONLY);
				                            #endif
				                        }
				                        break;
				                    }
				                }

				                if(KeyPad_Pos >= KeyPad_Code_Size)
				                {
				                    KeyPad_Error = false;
				                    #if     (KeyPad_INDIVIDUAL_TESTING == false)
				                    EP_Rx.KeyPad_Poll = false;
				                    #endif
				                    #if KeyPad_DEBUG_PRINTF
//				                        snprintf(tp, sizeof(tp), "Entered Code: %c%c%c%c%c%c", EP_Tx.KeyPad_Code[0], EP_Tx.KeyPad_Code[1],
//				                                 EP_Tx.KeyPad_Code[2], EP_Tx.KeyPad_Code[3], EP_Tx.KeyPad_Code[4], EP_Tx.KeyPad_Code[5]);
//				                        Log_Msg(T_KeypadEpaper, "INFO", tp, LOCAL_ONLY);
				                    #endif
				                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Transmit EP_Tx structure to BBComm Task

				                    /* Sending KE_T2B Struct to BB */
				                    Send_KE_T2B_Struct_ToBB(EP_Tx);

				                    break;
				                }
				                else if(KeyPad_Counter >= (KeyPad_Timeoutms / KeyPad_Polling_Timems))
				                {
				                    KeyPad_Error = true;
				                    #if KeyPad_DEBUG_PRINTF
				                        Log_Msg(T_KeypadEpaper, "WARNING", "Keypad Timed Out", LOGGER_AND_LOCAL);
				                    #endif
				                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send KE Failure LOG to BB
				                    break;
				                }
				            }
//				            taskEXIT_CRITICAL();
				            taskYIELD();
				}
			}
		}

		taskYIELD();
		//vTaskDelay(1000 / portTICK_PERIOD_MS);
	}
}


/*
 * Function to generate parity
 *
 * Param: Command Length
 *
 * Return: Calculated Parity Byte
 *
 */
uint8_t EP_Parity_Generator(uint16_t EP_Command_Length)
{
    static uint8_t EP_Parity_Loop_Counter, EP_Parity;
    EP_Parity = 0x00;
    EP_Command_Length -= 1;
    for(EP_Parity_Loop_Counter = 0; EP_Parity_Loop_Counter < EP_Command_Length; EP_Parity_Loop_Counter ++)
    {
        EP_Parity ^= EP_Command_Array[EP_Parity_Loop_Counter];
    }
    return EP_Parity;
}

/*
 * Function to initialize UART7 for E-Paper
 *
 * Param: Null
 * Return: Null
 *
 */
void EP_UART_Init(void)
{
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART7);

    GPIOPinConfigure(GPIO_PC4_U7RX);
    GPIOPinConfigure(GPIO_PC5_U7TX);
    GPIOPinTypeUART(GPIO_PORTC_BASE, GPIO_PIN_4 | GPIO_PIN_5);

    UARTConfigSetExpClk(UART7_BASE, SYSTEM_CLOCK, 115200,
                            (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                             UART_CONFIG_PAR_NONE));
}

/*
 * Function to transmit 1 byte over UART
 *
 * Param: Byte to transmit
 *
 * Return: Null
 *
 */
void EP_UART_Tx(uint8_t tx_byte)
{
    UARTCharPut(UART7_BASE, tx_byte);
}

/*
 * Function to receive 1 byte over UART with timeout
 *
 * Param: Null
 *
 * Return: Either Timeout Byte (0xFF) or received character
 *
 */
uint8_t EP_UART_Rx(void)
{
    EP_Response_ms_Counter = 0;

    while (HWREG(UART7_BASE + UART_O_FR) & UART_FR_RXFE)
    {
        vTaskDelay(1);
        EP_Response_ms_Counter += 1;
        if(EP_Update_Cmd == true)
        {
            if(EP_Response_Init == 0)
            {
                if(EP_Response_ms_Counter >= EP_Response_Start_Timeout_ms)      return 0xFF;
            }
            else
            {
                if(EP_Response_ms_Counter >= EP_Response_End_Timeout_ms)    return 0xFF;
            }
        }
        else
        {
            if(EP_Response_ms_Counter >= EP_Response_End_Timeout_ms)    return 0xFF;
        }
    }
    return (HWREG(UART7_BASE + UART_O_DR));
}

/*
 * Function to get back the entire response of module
 *
 * Param: Null
 *
 * Return: Null
 *
 */
void EP_Get_Response(void)
{
    volatile uint8_t Rx_Byte;
    uint8_t rx_arr[50], i, j;
    char tp[5];
    rx_arr[0] = 0;
    i = 0;
    do
    {
        Rx_Byte = EP_UART_Rx();
        if((Rx_Byte >= Valid_ASCII_Lowest) && (Rx_Byte <= Valid_ASCII_Highest))
        {
            EP_Response_Init = 0xFF;
            rx_arr[i++] = Rx_Byte;
        }
    }while(Rx_Byte != 0xFF);

    // Error Handling if EPaper is disconnected
    // It is done while supporting both - infinite as well as limited retries
    if(EP_Error == false)
    {
        if(rx_arr[0] == 0)
        {
            EP_Error = true;
            #if     (EP_Retry_Mode == EP_Limited)
                EP_Retries = EP_Max_Retries;
            #endif
        }
    }
    else
    {
        if(rx_arr[0] != 0)
        {
            EP_Error = false;
            #if     (EP_Retry_Mode == EP_Limited)
                EP_Retries = 0;
            #endif
        }
    }

#if     EP_DEBUG_PRINTF
    if(EP_StoreResp == true)
    {
    	strncpy(EP_FileName, &rx_arr[0], 20);
    	EP_StoreResp = false;
    }
//    for(j = 0; j < i; j ++)
//    {
//        snprintf(tp, sizeof(tp), "%c", rx_arr[j]);
//        Log_Msg(T_KeypadEpaper, "INFO", tp, LOCAL_ONLY);
//    }
#endif
}

/*
 * Function to send command over UART
 *
 * Param: Command ID
 * Param: Command Type
 *
 * Return: Null
 *
 */
void EP_Send_Command(uint8_t EP_Command_ID, uint8_t EP_Command_Type)
{
//    static char tp[5];
    static uint8_t EP_Command_Array_Local_Counter;
    if(EP_Command_Type != 0x00)
    {
        if(EP_Command_Type == 0x01) EP_Full_Command_Length = EP_Type1_Length;
        else if(EP_Command_Type == 0x02)    EP_Full_Command_Length = EP_Type2_Length;
        else if(EP_Command_Type == 0x03)    EP_Full_Command_Length = EP_Type3_Length;
        else if(EP_Command_Type == 0x04)    EP_Full_Command_Length = EP_Type4_Length;
    }
    EP_Command_Array_Local_Counter = 0;
    EP_Command_Array[EP_Command_Array_Local_Counter ++] = EP_Frame_Header;
    EP_Command_Array[EP_Command_Array_Local_Counter ++] = (uint8_t)((EP_Full_Command_Length & 0xFF00) >> 8);
    EP_Command_Array[EP_Command_Array_Local_Counter ++] = (uint8_t)(EP_Full_Command_Length & 0x00FF);
    EP_Command_Array[EP_Command_Array_Local_Counter ++] = EP_Command_ID;
    if(EP_Command_Type == EP_Storage_Set_Type)
    {
        EP_Command_Array[EP_Command_Array_Local_Counter ++] = EP_Set_SD_Storage;
    }
    else if(EP_Command_Type == 0x03)
    {
        EP_Command_Array[EP_Command_Array_Local_Counter ++] = 0x03;
        EP_Command_Array[EP_Command_Array_Local_Counter ++] = 0x00;
    }
    else if((EP_Command_Type == 0x00) || (EP_Command_Type == 0x04))
    {
        EP_Command_Array_Local_Counter = EP_Command_Array_Universal_Counter;
    }
    EP_Command_Array[EP_Command_Array_Local_Counter ++] = EP_Frame_End_1;
    EP_Command_Array[EP_Command_Array_Local_Counter ++] = EP_Frame_End_2;
    EP_Command_Array[EP_Command_Array_Local_Counter ++] = EP_Frame_End_3;
    EP_Command_Array[EP_Command_Array_Local_Counter ++] = EP_Frame_End_4;
    EP_Command_Array[EP_Command_Array_Local_Counter ++] = EP_Parity_Generator(EP_Full_Command_Length);
//    EP_Print("\n");
//    for(EP_Command_Array_Local_Counter = 0; EP_Command_Array_Local_Counter < EP_Full_Command_Length; EP_Command_Array_Local_Counter ++)
//    {
//        snprintf(tp, sizeof(tp), "%x ", EP_Command_Array[EP_Command_Array_Local_Counter]);
//        EP_Print(tp);
//    }

    taskENTER_CRITICAL();
    for(EP_Command_Array_Local_Counter = 0; EP_Command_Array_Local_Counter < EP_Full_Command_Length; EP_Command_Array_Local_Counter ++)
    {
        EP_UART_Tx(EP_Command_Array[EP_Command_Array_Local_Counter]);
    }
    taskEXIT_CRITICAL();
    EP_Response_Init = 0x00;

#if     EP_DEBUG_PRINTF
//    Log_Msg(T_KeypadEpaper, "INFO", "Resp:", LOCAL_ONLY);
#endif

    EP_Get_Response();
}

/*
 * Function to set command array for drawing a circle
 *
 * Param: X axis position of the center of the circle
 * Param: Y axis position of the center of the circle
 * Param: Radius of the circle
 *
 * Return: Null
 *
 */
void EP_Set_Circle_CMD(uint16_t EP_Circle_Center_X_Pos, uint16_t EP_Circle_Center_Y_Pos, uint16_t EP_Circle_Radius)
{
    EP_Command_Array_Universal_Counter = 4;
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)((EP_Circle_Center_X_Pos & 0xFF00) >> 8);
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)(EP_Circle_Center_X_Pos & 0x00FF);
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)((EP_Circle_Center_Y_Pos & 0xFF00) >> 8);
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)(EP_Circle_Center_Y_Pos & 0x00FF);
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)((EP_Circle_Radius & 0xFF00) >> 8);
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)(EP_Circle_Radius & 0x00FF);
}

/*
 * Function to draw circle on the screen
 *
 * Param: X axis position of the center of the circle
 * Param: Y axis position of the center of the circle
 * Param: Radius of the circle
 *
 * Return: Null
 *
 */
void EP_Draw_Circle(uint16_t EP_Circle_Center_X_Pos, uint16_t EP_Circle_Center_Y_Pos, uint16_t EP_Circle_Radius)
{
  EP_Send_Command(EP_CMD_Set_Draw_Color, EP_Set_Draw_Color_Type);
  EP_Send_Command(EP_CMD_Get_Draw_Color, EP_Get_Draw_Color_Type);
  EP_Send_Command(EP_CMD_Clear, EP_Clear_Type);
  EP_Set_Circle_CMD(EP_Circle_Center_X_Pos, EP_Circle_Center_Y_Pos, EP_Circle_Radius);
  EP_Send_Command(EP_CMD_Fill_Circle, EP_Fill_Circle);
  EP_Update_Cmd = true;
  EP_Send_Command(EP_CMD_Refresh_Update, EP_Refresh_Update_Type);
  EP_Update_Cmd = false;
}

/*
 * Function to set command array for displaying image
 *
 * Param: String containing image name
 * Param: X axis position of the pixel to start drawing from (top left is (0,0))
 * Param: Y axis position of the pixel to start drawing from (top left is (0,0))
 *
 * Return: Null
 *
 */
void EP_Set_Image_CMD(char *EP_Image_Name, uint16_t EP_Image_X_Start_Pos, uint16_t EP_Image_Y_Start_Pos)
{
    EP_Image_String_Counter = 0;
    EP_Command_Array_Universal_Counter = 4;
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)((EP_Image_X_Start_Pos & 0xFF00) >> 8);
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)(EP_Image_X_Start_Pos & 0x00FF);
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)((EP_Image_Y_Start_Pos & 0xFF00) >> 8);
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = (uint8_t)(EP_Image_Y_Start_Pos & 0x00FF);
    while(*EP_Image_Name != 0x00)
    {
        EP_Command_Array[EP_Command_Array_Universal_Counter ++] = *EP_Image_Name++;
        EP_Image_String_Counter += 1;
    }
    EP_Command_Array[EP_Command_Array_Universal_Counter ++] = 0;
    EP_Image_String_Counter += 1;
    EP_Full_Command_Length = EP_Display_Image_CMD_Length(EP_Image_String_Counter);
}

/*
 * Function to display image on screen
 *
 * Param: String containing image name
 * Param: X axis position of the pixel to start drawing from (top left is (0,0))
 * Param: Y axis position of the pixel to start drawing from (top left is (0,0))
 *
 * Return: Null
 *
 */
void EP_Display_Image(char *EP_Image_Name, uint16_t EP_Image_X_Start_Pos, uint16_t EP_Image_Y_Start_Pos)
{
    EP_Set_Image_CMD(EP_Image_Name, 0, 0);
    EP_Send_Command(EP_CMD_Display_Image, EP_CMD_Display_Image_Type);
    EP_Update_Cmd = true;
    EP_Send_Command(EP_CMD_Refresh_Update, EP_Refresh_Update_Type);
    EP_Update_Cmd = false;
}

/*
 * Function to setup GPIO pins for KeyPad
 *
 * Param: Null
 *
 * Return: Null
 *
 */
void KeyPad_Init(void)
{
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOM);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOH);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPION);

    GPIOPinTypeGPIOOutput(GPIO_PORTK_BASE, GPIO_PIN_5);
    GPIOPinTypeGPIOOutput(GPIO_PORTM_BASE, GPIO_PIN_0);
    GPIOPinTypeGPIOOutput(GPIO_PORTM_BASE, GPIO_PIN_1);
    GPIOPinTypeGPIOOutput(GPIO_PORTM_BASE, GPIO_PIN_2);

    GPIOPinTypeGPIOOutput(GPIO_PORTN_BASE, GPIO_PIN_0);

    GPIOPinTypeGPIOInput(GPIO_PORTH_BASE, GPIO_PIN_0);
    GPIOPinTypeGPIOInput(GPIO_PORTH_BASE, GPIO_PIN_1);
    GPIOPinTypeGPIOInput(GPIO_PORTK_BASE, GPIO_PIN_6);
    GPIOPinTypeGPIOInput(GPIO_PORTK_BASE, GPIO_PIN_7);

    GPIOPadConfigSet(GPIO_PORTH_BASE, GPIO_PIN_0, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPD);
    GPIOPadConfigSet(GPIO_PORTH_BASE, GPIO_PIN_1, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPD);
    GPIOPadConfigSet(GPIO_PORTK_BASE, GPIO_PIN_6, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPD);
    GPIOPadConfigSet(GPIO_PORTK_BASE, GPIO_PIN_7, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPD);
}

/*
 * Function to select and set the specifc row high (3.3V)
 *
 * Param: uint8_t row (from 0 to 3)
 *
 * Return: Null
 *
 */
void KeyPad_SelectRow(uint8_t row)
{
    switch(row)
    {
        case 0:
            GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_5, GPIO_PIN_5);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_0, false);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_1, false);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_2, false);
            break;
        case 1:
            GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_5, false);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_0, GPIO_PIN_0);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_1, false);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_2, false);
            break;
        case 2:
            GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_5, false);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_0, false);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_1, GPIO_PIN_1);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_2, false);
            break;
        case 3:
            GPIOPinWrite(GPIO_PORTK_BASE, GPIO_PIN_5, false);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_0, false);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_1, false);
            GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_2, GPIO_PIN_2);
            break;
    }
}

/*
 * Function to blink the User LED 0 (PN0) when
 * a key is pressed
 *
 * Param: Null
 *
 * Return: Null
 *
 */
void KeyPad_BlinkLED(void)
{
    GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);
    vTaskDelay(500);
    GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, false);
}

/*
 * Function to scan the columns and if any key is pressed,
 * store the ASCII representation of that key in the array
 * that will be sent to the Control Node. This function also
 * supports timeout - so if no key is pressed withing given time,
 * it will raise an error flag and exit polling
 *
 * Param: uint8_t row (from 0 to 3)
 *
 * Return: boolean state (false: No key was pressed, true: key pressed)
 *
 */
bool KeyPad_ScanCode(uint8_t row)
{
    char tp[50];
    uint32_t stat;

    stat = 0;
    stat = GPIOPinRead(GPIO_PORTH_BASE, GPIO_PIN_0) & 0x00FF;
    if(stat != 0)
    {
        KeyPad_Counter = 0;
        EP_Tx.KeyPad_Code[KeyPad_Pos] = Key_LookUp[row][3];
        #if KeyPad_DEBUG_PRINTF
            snprintf(tp, sizeof(tp), "Pressed Key: %c", EP_Tx.KeyPad_Code[KeyPad_Pos]);
            Log_Msg(T_KeypadEpaper, "INFO", tp, LOCAL_ONLY);
        #endif
        KeyPad_Pos += 1;
        KeyPad_BlinkLED();
        vTaskDelay(KeyPad_Wait_Timems);
        return true;
    }

    stat = 0;
    stat = GPIOPinRead(GPIO_PORTH_BASE, GPIO_PIN_1) & 0x00FF;
    if(stat != 0)
    {
        KeyPad_Counter = 0;
        EP_Tx.KeyPad_Code[KeyPad_Pos] = Key_LookUp[row][2];
        #if KeyPad_DEBUG_PRINTF
        	snprintf(tp, sizeof(tp), "Pressed Key: %c", EP_Tx.KeyPad_Code[KeyPad_Pos]);
            Log_Msg(T_KeypadEpaper, "INFO", tp, LOCAL_ONLY);
        #endif
        KeyPad_Pos += 1;
        KeyPad_BlinkLED();
        vTaskDelay(KeyPad_Wait_Timems);
        return true;
    }

    stat = 0;
    stat = GPIOPinRead(GPIO_PORTK_BASE, GPIO_PIN_6) & 0x00FF;
    if(stat != 0)
    {
        KeyPad_Counter = 0;
        EP_Tx.KeyPad_Code[KeyPad_Pos] = Key_LookUp[row][1];
        #if KeyPad_DEBUG_PRINTF
        	snprintf(tp, sizeof(tp), "Pressed Key: %c", EP_Tx.KeyPad_Code[KeyPad_Pos]);
            Log_Msg(T_KeypadEpaper, "INFO", tp, LOCAL_ONLY);
        #endif
        KeyPad_Pos += 1;
        KeyPad_BlinkLED();
        vTaskDelay(KeyPad_Wait_Timems);
        return true;
    }

    stat = 0;
    stat = GPIOPinRead(GPIO_PORTK_BASE, GPIO_PIN_7) & 0x00FF;
    if(stat != 0)
    {
        KeyPad_Counter = 0;
        EP_Tx.KeyPad_Code[KeyPad_Pos] = Key_LookUp[row][0];
        #if KeyPad_DEBUG_PRINTF
        	snprintf(tp, sizeof(tp), "Pressed Key: %c", EP_Tx.KeyPad_Code[KeyPad_Pos]);
            Log_Msg(T_KeypadEpaper, "INFO", tp, LOCAL_ONLY);
        #endif
        KeyPad_Pos += 1;
        KeyPad_BlinkLED();
        vTaskDelay(KeyPad_Wait_Timems);
        return true;
    }

    vTaskDelay(KeyPad_Polling_Timems);
    KeyPad_Counter += 1;

    return false;
}
/*
 * Global_Defines.h
 *
 *  Created on: Apr 8, 2019
 *      Author: Khalid AlAwadhi
 */

#ifndef MY_INCLUDES_GLOBAL_DEFINES_H_
#define MY_INCLUDES_GLOBAL_DEFINES_H_

#include <stdint.h>
#include <stdbool.h>

/////////////////////////////////////// COMMON BETWEEN TIVA AND BB ///////////////////////////////////////////////////////////
/***************************************
 *   Current Program Version define    *
 ***************************************/
#define CURRENT_VER 				"1.9"


/***************************************
 *  Task and Thread Numbering Enum:    *
 *  Used for source and destination    *
 ***************************************/
typedef enum
{
	/* Tiva Sources */
	T_Main = 1,
	T_BBComm = 2,
	T_NFC = 3,
	T_KeypadEpaper = 4,
	T_LoadCell = 5,
	T_Lux = 6,
	T_Servo = 7,
	T_SpeakJet = 8,
	T_Outputs = 9,
	T_BME = 16,
	/* BeagleBone Sources */
	BB_Main = 10,
	BB_Logger = 11,
	BB_TivaComm = 12,
	BB_NFC = 13,
	BB_KeypadEpaper = 14,
	BB_LoadCell = 15
} Sources;


/*****************************************
 * UART Bluetooth CMDs used in the code  *
 * logic to know where we are when TXing *
 * or RXing                              *
 *****************************************/
#define START_CMD                  "?"
#define START_CMD_CHAR             '?'
#define CONFIRM_CMD                "#"
#define END_CMD                    "!"
#define END_CMD_CHAR               '!'


/*****************************************
 * String size defines                   *
 *****************************************/
//This define should be used when sizing
//strings that will be used to store
//messages in the system. Helps keeps
//things consistent
#define MSGSTR_SIZE                 150
#define LOG_SIZE                    20
#define SRC_SIZE                    21


/***************************************
 *     Max Structure size              *
 ***************************************/
#define MAX_STRUCT_SIZE				220


/***************************************
 *     Struct ID Enum                  *
 ***************************************/
typedef enum
{
	LogMsg_Struct_ID = 1,
	NFC_T2B_Struct_ID = 2,
	KE_B2T_Struct_ID = 3,
	KE_T2B_Struct_ID = 4,
	LC_B2T_Struct_ID = 5,
	LC_T2B_Struct_ID = 6,
	OI_B2T_Struct_ID = 7
} Struct_ID;


/***************************************
 *  Struct used by Logger thread/task  *
 ***************************************/
typedef struct
{
	uint8_t ID;
	uint8_t Src;
	char LogLevel[LOG_SIZE];		//Expected values: INFO | WARNING | ERROR | CRITICAL | FATAL
	char Msg[MSGSTR_SIZE];
} LogMsg_Struct;

/***************************************
 *  Struct used by NFC thread/task     *
 *  (Tiva to BB)                       *
 ***************************************/
typedef struct
{
    uint8_t ID;
    uint8_t Src;
    uint8_t NFC_Tag_ID_Array[4];
} NFC_T2B_Struct;


/***************************************
 *  Struct used by NFC pThread /       *
 *  KeypadEpaper task (BB to Tiva)     *
 ***************************************/
typedef struct
{
    uint8_t ID;
    uint8_t Src;
    bool KeyPad_Poll;
    bool EP_Update;
    char Image_Name[10];
} KE_B2T_Struct;


/***************************************
 *  Struct used by KeypadEpaper task / *
 *  pThread (Tiva to BB)               *
 ***************************************/
typedef struct
{
    uint8_t ID;
    uint8_t Src;
    uint8_t KeyPad_Code[6];
} KE_T2B_Struct;


/***************************************
 *  Struct used by KeypadEpaper pThread*
 *   / LoadCell task (BB to Tiva)      *
 ***************************************/
typedef struct
{
    uint8_t ID;
    uint8_t Src;
    bool LC_Poll;
} LC_B2T_Struct;

/***************************************
 *  Struct used by LoadCell task/thread*
 *  (Tiva to BB)                       *
 ***************************************/
typedef struct
{
    uint8_t ID;
    uint8_t Src;
    uint16_t LC_SamplesArraymv[20];
} LC_T2B_Struct;


/***************************************
 *  Struct sent from LoadCell pThread  *
 *  to Outputs Task                    *
 *  (BB to Tiva)                       *
 ***************************************/
typedef struct
{
	uint8_t ID;
    uint8_t Src;
    uint8_t OI_Data;
} OI_B2T_Struct;


/***************************************
 *   Log_Msg() Function Parameters:    *
 *   (found in Master_Functions.h)     *
 ***************************************/
#define LOGGER_AND_LOCAL			0x01
#define LOGGER_ONLY					0x02
#define LOCAL_ONLY					0x03


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



#define RX_TIMEOUT_VALUE               1100000

/*****************************************
 *      System Clock Rate, 120 MHz       *
 *****************************************/
#define SYSTEM_CLOCK    120000000U


/*****************************************
 *      Priorities of Tasks              *
 *****************************************/
#define PRIORITY_LOGGER_TASK			0
#define PRIORITY_BBCOMM_TASK			2
#define PRIORITY_NFC_TASK				1
#define PRIORITY_KEYPADEPAPER_TASK		0
#define PRIORITY_LOADCELL_TASK			0
#define PRIORITY_LUX_TASK				0
#define PRIORITY_SERVO_TASK				0
#define PRIORITY_BME_TASK			0
#define PRIORITY_OUTPUTS_TASK			0


#endif /* MY_INCLUDES_GLOBAL_DEFINES_H_ */
/*
 * SpeakJet_Task.h
 *
 *  Created on: Apr 25, 2019
 *      Author:  Author: Khalid AlAwadhi
 */

#ifndef MY_INCLUDES_BME280TASK_H_
#define MY_INCLUDES_BME280TASK_H_

#include <stdint.h>
#include <stdbool.h>

#define BME280_Infinite             true
#define BME280_Limited              false

#define BME280_Retry_Mode           BME280_Infinite

#if     (BME280_Retry_Mode == BME280_Limited)
#define BME280_Max_Retries          5
#endif

#define BME280_Polling_Timems       2500

#define BME280_Host_Unknown           false

#if     BME280_Host_Unknown
    #define BME280_Print   UARTprintf
#else
    #define BME280_Print   cust_print
#endif

#define BME280_INDIVIDUAL_TESTING  false

#define BME280_DEBUG_PRINTF        true

#define BME280_Temp_High_Threshold      30
#define BME280_Temp_Low_Threshold       20

#define BME280_Humidity_High_Threshold      50

#define BME280_DevID        0x60

#define BME280_DataRegNos           8

#define BME280_Pressure_MSB_Pos     0
#define BME280_Pressure_LSB_Pos     1
#define BME280_Pressure_XLSB_Pos    2

#define BME280_Temp_MSB_Pos     3
#define BME280_Temp_LSB_Pos     4
#define BME280_Temp_XLSB_Pos    5

#define BME280_Hum_MSB_Pos     6
#define BME280_Hum_LSB_Pos     7

#define BME280_MODE_Pos            0
#define BME280_MODE_MASK           0x03
#define BME280_MODE_SLEEP          0x00
#define BME280_MODE_FORCED         0x01
#define BME280_MODE_NORMAL         0x03

#define BME280_Standby_Pos         5
#define BME280_Standby_Mask        0xE0
#define BME280_Standby_500us       0x00
#define BME280_Standby_62500us     0x01
#define BME280_Standby_125ms       0x02
#define BME280_Standby_250ms       0x03
#define BME280_Standby_500ms       0x04
#define BME280_Standby_1000ms      0x05
#define BME280_Standby_10ms        0x06
#define BME280_Standby_20ms        0x07

#define BME280_Hum_OVS_Pos         0
#define BME280_Hum_OVS_Mask        0x07
#define BME280_Hum_OVS_Skip        0x00
#define BME280_Hum_OVS1            0x01
#define BME280_Hum_OVS2            0x02
#define BME280_Hum_OVS4            0x03
#define BME280_Hum_OVS8            0x04
#define BME280_Hum_OVS16           0x05

#define BME280_Temp_OVS_Pos         5
#define BME280_Temp_OVS_Mask        0xE0
#define BME280_Temp_OVS_Skip        0x00
#define BME280_Temp_OVS1            0x01
#define BME280_Temp_OVS2            0x02
#define BME280_Temp_OVS4            0x03
#define BME280_Temp_OVS8            0x04
#define BME280_Temp_OVS16           0x05

#define BME280_Pressure_OVS_Pos         2
#define BME280_Pressure_OVS_Mask        0x1C
#define BME280_Pressure_OVS_Skip        0x00
#define BME280_Pressure_OVS1            0x01
#define BME280_Pressure_OVS2            0x02
#define BME280_Pressure_OVS4            0x03
#define BME280_Pressure_OVS8            0x04
#define BME280_Pressure_OVS16           0x05

//Register names:
#define BME280_DIG_T1_LSB_REG           0x88
#define BME280_DIG_T1_MSB_REG           0x89
#define BME280_DIG_T2_LSB_REG           0x8A
#define BME280_DIG_T2_MSB_REG           0x8B
#define BME280_DIG_T3_LSB_REG           0x8C
#define BME280_DIG_T3_MSB_REG           0x8D
#define BME280_DIG_P1_LSB_REG           0x8E
#define BME280_DIG_P1_MSB_REG           0x8F
#define BME280_DIG_P2_LSB_REG           0x90
#define BME280_DIG_P2_MSB_REG           0x91
#define BME280_DIG_P3_LSB_REG           0x92
#define BME280_DIG_P3_MSB_REG           0x93
#define BME280_DIG_P4_LSB_REG           0x94
#define BME280_DIG_P4_MSB_REG           0x95
#define BME280_DIG_P5_LSB_REG           0x96
#define BME280_DIG_P5_MSB_REG           0x97
#define BME280_DIG_P6_LSB_REG           0x98
#define BME280_DIG_P6_MSB_REG           0x99
#define BME280_DIG_P7_LSB_REG           0x9A
#define BME280_DIG_P7_MSB_REG           0x9B
#define BME280_DIG_P8_LSB_REG           0x9C
#define BME280_DIG_P8_MSB_REG           0x9D
#define BME280_DIG_P9_LSB_REG           0x9E
#define BME280_DIG_P9_MSB_REG           0x9F
#define BME280_DIG_H1_REG               0xA1
#define BME280_CHIP_ID_REG              0xD0 //Chip ID
#define BME280_RST_REG                  0xE0 //Softreset Reg
#define BME280_DIG_H2_LSB_REG           0xE1
#define BME280_DIG_H2_MSB_REG           0xE2
#define BME280_DIG_H3_REG               0xE3
#define BME280_DIG_H4_MSB_REG           0xE4
#define BME280_DIG_H4_LSB_REG           0xE5
#define BME280_DIG_H5_MSB_REG           0xE6
#define BME280_DIG_H6_REG               0xE7
#define BME280_CTRL_HUMIDITY_REG        0xF2 //Ctrl Humidity Reg
#define BME280_STAT_REG                 0xF3 //Status Reg
#define BME280_CTRL_MEAS_REG            0xF4 //Ctrl Measure Reg
#define BME280_CONFIG_REG               0xF5 //Configuration Reg
#define BME280_PRESSURE_MSB_REG         0xF7 //Pressure MSB
#define BME280_PRESSURE_LSB_REG         0xF8 //Pressure LSB
#define BME280_PRESSURE_XLSB_REG        0xF9 //Pressure XLSB
#define BME280_TEMPERATURE_MSB_REG      0xFA //Temperature MSB
#define BME280_TEMPERATURE_LSB_REG      0xFB //Temperature LSB
#define BME280_TEMPERATURE_XLSB_REG     0xFC //Temperature XLSB
#define BME280_HUMIDITY_MSB_REG         0xFD //Humidity MSB
#define BME280_HUMIDITY_LSB_REG         0xFE //Humidity LSB

/**************************************************************************************************************
 * USAGE: This function will initialize the SpeakJet task
 *
 * PARAMETERS:
 *            - NONE
 *
 * RETURNS: 0 => Init was successful
 * 			1 => Init failed
 **************************************************************************************************************/
uint8_t BME_TaskInit();


/**************************************************************************************************************
 * USAGE: This function XXX
 *
 * PARAMETERS:
 *            - NONE
 *
 * RETURNS: NONE
 **************************************************************************************************************/
void BME_Task(void *pvParameters);

void BME280_SPISetup(void);
uint8_t BME280_SPIReadReg(uint8_t spi_addr);
void BME280_SPIReadMultiReg(uint32_t *rx_addr, uint8_t start_addr, uint8_t no_of_regs);
void BME280_SPIWriteReg(uint8_t spi_addr, uint8_t spi_data);
void BME280_SetStandBy(uint8_t timeout);
uint8_t BME280_GetStandBy(void);
void BME280_SetMode(uint8_t mode);
uint8_t BME280_GetMode(void);
void BME280_SetHumOVS(uint8_t ovs);
void BME280_SetTempOVS(uint8_t ovs);
void BME280_SetPressureOVS(uint8_t ovs);
void BME280_ReadAllCalib(void);
void BME280_ReadAllDataReg(void);
void BME280_GetPressure(float *var_p);
void BME280_GetTemp(float *var_t);
void BME280_GetHum(float *var_h);
bool BME280_SensorSetup(void);
void BME280_TestSensor(void);

#endif /* MY_INCLUDES_BME280TASK_H_ */
/*
 * BBComm_Task.h
 *
 *  Created on: Apr 15, 2019
 *      Author:  Author: Khalid AlAwadhi
 */

#ifndef MY_INCLUDES_BBCOMM_TASK_H_
#define MY_INCLUDES_BBCOMM_TASK_H_

#include <stdint.h>

/**************************************************************************************************************
 * USAGE: This function will initialize the BBComm task
 *
 * PARAMETERS:
 *            - NONE
 *
 * RETURNS: 0 => Init was successful
 * 			1 => Init failed
 **************************************************************************************************************/
uint8_t BBComm_TaskInit();


/**************************************************************************************************************
 * USAGE: This function handles communication with the external BeagleBone board via UART.
 *
 * PARAMETERS:
 *            - NONE
 *
 * RETURNS: NONE
 **************************************************************************************************************/
void BBComm_Task(void *pvParameters);



/**************************************************************************************************************
 * USAGE: This function decodes a given buffer containing buffer data, created the structure needed and then
 *        send it to the targeted thread.
 *
 * PARAMETERS:
 *            - uint8_t* StructToDecode => The buffer with structure data to decode
 *
 * RETURNS: NONE
 **************************************************************************************************************/
void Decode_StructBuffer(uint8_t* StructToDecode);




#endif /* MY_INCLUDES_BBCOMM_TASK_H_ */
/*
 * SpeakJet_Task.c
 *
 *  Created on: Apr 25, 2019
 *      Author:  Author: Khalid AlAwadhi
 */

#include <BME280Task.h>
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

//My includes
#include "Global_Defines.h"
#include "Master_Functions.h"

// Standard Includes
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>

#include "drivers/pinout.h"
#include "utils/uartstdio.h"

// Third Party Includes
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_i2c.h"
#include "inc/hw_sysctl.h"
#include "inc/hw_types.h"
#include "inc/hw_uart.h"
#include "inc/hw_adc.h"
#include "inc/hw_ssi.h"

// TivaWare includes
#include "driverlib/sysctl.h"
#include "driverlib/debug.h"
#include "driverlib/rom.h"
#include "driverlib/interrupt.h"
#include "driverlib/i2c.h"
#include "driverlib/debug.h"
#include "driverlib/gpio.h"
#include "driverlib/pin_map.h"
#include "driverlib/uart.h"
#include "driverlib/timer.h"
#include "driverlib/fpu.h"
#include "driverlib/adc.h"
#include "driverlib/ssi.h"

//#include "sensorlib/i2cm_drv.h"

/* Global Variables */

//>>>>>>>>>>>>>>> Share following 2 variables among Tasks

bool Temperature_Alert, Humidity_Alert;

// Variables that will be shared between functions
typedef struct
{
    uint16_t dig_T1;
    int16_t dig_T2;
    int16_t dig_T3;

    uint16_t dig_P1;
    int16_t dig_P2;
    int16_t dig_P3;
    int16_t dig_P4;
    int16_t dig_P5;
    int16_t dig_P6;
    int16_t dig_P7;
    int16_t dig_P8;
    int16_t dig_P9;

    uint8_t dig_H1;
    int16_t dig_H2;
    uint8_t dig_H3;
    int16_t dig_H4;
    int16_t dig_H5;
    int8_t dig_H6;
}SensorCalibration;

SensorCalibration   BME280_calib;

uint32_t BME280_Tx[2];
uint32_t BME280_Rx;
bool BME280_RunStatus, BME280_Error;
uint32_t BME280_Data[8];
int32_t BME280_TempFine;
uint8_t BME280_Retries;

uint8_t BME_TaskInit()
{
    //Create task, if it fails return 1, else 0
    if( xTaskCreate(BME_Task,					/* The function that implements the task */
			   (const portCHAR *)"BME",		/* The text name assigned to the task - for debug only as it is not used by the kernel */
               ((configMINIMAL_STACK_SIZE) * 10),	/* The size of the stack to allocate to the task */
			   NULL,								/* The parameter passed to the task */
			   PRIORITY_BME_TASK,	 			/* The priority assigned to the task */
			   NULL)								/* The task handle is not required, so NULL is passed */
    			!= pdTRUE
      )
      {
    	return 1;
      }

	return 0;
}



void BME_Task(void *pvParameters)
{

    BME280_RunStatus = false;
    BME280_Error = false;

    Temperature_Alert = false;
    Humidity_Alert = false;

    static char tp[200];

    BME280_SPISetup();
    BME280_Error = BME280_SensorSetup();

    if(BME280_Error == true)
    {
        //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send BME280 BIST Failure LOG to BB
        #if     (BME280_Retry_Mode == BME280_Limited)
            BME280_Retries = BME280_Max_Retries;
        #endif
        #if     BME280_DEBUG_PRINTF
            Log_Msg(T_BME, "ERROR", "BME280 Setup Failed!", LOCAL_ONLY);
        #endif
    }
    else
    {
        //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send BME280 BIST Success LOG to BB
        #if     BME280_DEBUG_PRINTF
            Log_Msg(T_BME, "INFO", "BME280 Setup Succeeded!", LOCAL_ONLY);
            Log_Msg(T_BME, "INFO", "BME280 Normal Operation", LOCAL_ONLY);
        #endif
    }

    static float temperature, humidity;
//    static float ref_pressure = 101325.0;

//    static float pressure, height;

    BME280_RunStatus = true;

	while(1)
	{
        vTaskDelay(BME280_Polling_Timems);

        if(BME280_Error == false)
        {
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send BME280 Online LOG to BB
            BME280_TestSensor();
            #if     BME280_DEBUG_PRINTF
                    Log_Msg(T_BME, "INFO", "Checking BME280 Status...", LOCAL_ONLY);
                    if(BME280_Error == false)   Log_Msg(T_BME, "INFO", "BME280 is Online", LOCAL_ONLY);
                    else    Log_Msg(T_BME, "ERROR", "BME280 is Offline", LOCAL_ONLY);
            #endif
        }
        else
        {
            //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send BME280 Failure LOG to BB
            #if     (BME280_Retry_Mode == BME280_Limited)
                if(BME280_Retries != 0x00)
                {
                    BME280_Retries -= 1;
            #endif
                    BME280_SPISetup();
                    BME280_Error = BME280_SensorSetup();
            #if     (BME280_Retry_Mode == BME280_Limited)
                }
            #endif
        }

        // Note: Poll_BME280 flag shouldn't be cleared automatically.
        if(BME280_Error == false)
        {
            BME280_ReadAllDataReg();
            BME280_GetTemp(&temperature);
            BME280_GetHum(&humidity);

            if(BME280_Error == false)
            {
                if(temperature > BME280_Temp_High_Threshold)
                {
                    #if     BME280_DEBUG_PRINTF

                        Log_Msg(T_BME, "WARNING", "Temperature Too High... Alert!", LOCAL_ONLY);
                    #endif
                    Temperature_Alert = true;
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send Temp Too High Alert (with value) LOG to BB
                }
                else if(temperature < BME280_Temp_Low_Threshold)
                {
                    #if     BME280_DEBUG_PRINTF
                        Log_Msg(T_BME, "WARNING", "Temperature Too Low... Alert!", LOCAL_ONLY);
                    #endif
                    Temperature_Alert = true;
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send Temp Too Low Alert (with value) LOG to BB
                }
                else
                {
                    #if     BME280_DEBUG_PRINTF
                        Log_Msg(T_BME, "INFO", "Temperature is Normal", LOCAL_ONLY);
                    #endif
                    Temperature_Alert = false;
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send Temp Normal (with value) LOG to BB
                }

                if(humidity > BME280_Humidity_High_Threshold)
                {
                    #if     BME280_DEBUG_PRINTF

                        Log_Msg(T_BME, "WARNING", "Humidity Too High... Alert!", LOCAL_ONLY);
                    #endif
                    Humidity_Alert = true;
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send Humidity Too High Alert (with value) LOG to BB
                }
                else
                {
                    #if     BME280_DEBUG_PRINTF

                        Log_Msg(T_BME, "INFO", "Humidity is Normal", LOCAL_ONLY);
                    #endif
                    Humidity_Alert = false;
                    //>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Send Humidity Normal (with value) LOG to BB
                }

                #if     BME280_DEBUG_PRINTF
                    snprintf(tp, sizeof(tp), "\nTemp. - %.2fC(%.2fF) R.H. - %.2f%", temperature,
                             ((temperature * 1.8) + 32), humidity);

                    Log_Msg(T_BME, "INFO", tp, LOCAL_ONLY);

                #endif
            }
//            else
//            {
//                #if     BME280_DEBUG_PRINTF
//                    BME280_Print("\nBME280 is Offline");
//                #endif
//            }
        }
	}
}

/*
 * Function to setup SPI bus for BME280
 *
 * Param: Null
 *
 * Return: Null
 *
 */
void BME280_SPISetup(void)
{
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_SSI0);
    GPIOPinConfigure(GPIO_PA2_SSI0CLK);
    GPIOPinConfigure(GPIO_PA4_SSI0XDAT0);
    GPIOPinConfigure(GPIO_PA5_SSI0XDAT1);

    GPIOPinTypeGPIOOutput(GPIO_PORTA_BASE, GPIO_PIN_3);
    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, GPIO_PIN_3);

    GPIOPinTypeSSI(GPIO_PORTA_BASE, GPIO_PIN_5 | GPIO_PIN_4 |
                   GPIO_PIN_2);

    SSIConfigSetExpClk(SSI0_BASE, SYSTEM_CLOCK, SSI_FRF_MOTO_MODE_0,
                       SSI_MODE_MASTER, 1000000, 8);

    SSIEnable(SSI0_BASE);

    while(SSIDataGetNonBlocking(SSI0_BASE, &BME280_Rx));
}

/*
 * Function to read a single byte from sensor using SPI bus
 * If there is no valid byte then it raises the error flag
 * and sets other variables as per the retry mode
 *
 * Param: Internal Register Address which is to be read
 *
 * Return: Byte which was returned from Sensor
 *
 */
uint8_t BME280_SPIReadReg(uint8_t spi_addr)
{
    BME280_Tx[0] = spi_addr | (1 << 7);
    BME280_Tx[1] = 0x00;

    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, false);

    SSIDataPut(SSI0_BASE, BME280_Tx[0]);
    while(SSIBusy(SSI0_BASE));
    SSIDataPut(SSI0_BASE, BME280_Tx[1]);
    while(SSIBusy(SSI0_BASE));

    SSIDataGet(SSI0_BASE, &BME280_Rx);
    SSIDataGet(SSI0_BASE, &BME280_Rx);

    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, GPIO_PIN_3);

    if((BME280_RunStatus == true) && ((BME280_Rx & 0x00FF) == 0xFF))
    {
        BME280_Error = true;
        #if     (BME280_Retry_Mode == BME280_Limited)
            BME280_Retries = BME280_Max_Retries;
        #endif
        #if     BME280_DEBUG_PRINTF
            Log_Msg(T_BME, "ERROR", "BME280 is Offline", LOCAL_ONLY);
        #endif
    }

    return (BME280_Rx & 0x00FF);
}

/*
 * Function to read multiple registers (in consecutive locations) of Sensor
 *
 * Param_1: Pointer to the array/buffer where the return bytes should be stored
 * Param_2: Starting address (lowest in series) of the internal register
 * Param_3: Number of registers/8 bit locations to be read
 *
 * Return: Null
 *
 */
void BME280_SPIReadMultiReg(uint32_t *rx_addr, uint8_t start_addr, uint8_t no_of_regs)
{
    static uint8_t i;

    BME280_Tx[0] = start_addr | (1 << 7);
    BME280_Tx[1] = 0x00;

    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, false);

    SSIDataPut(SSI0_BASE, BME280_Tx[0]);
    while(SSIBusy(SSI0_BASE));
    SSIDataGet(SSI0_BASE, rx_addr);

    for(i = 0; i < no_of_regs; i ++)
    {
        SSIDataPut(SSI0_BASE, BME280_Tx[1]);
        while(SSIBusy(SSI0_BASE));
        SSIDataGet(SSI0_BASE, rx_addr++);
    }

    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, GPIO_PIN_3);
}

/*
 * Function to write 8 bit data to the internal register of the sensor
 *
 * Param_1: Address of the internal sensor
 * Param_2: 8 bit data to be writeen
 *
 * Return: Null
 *
 */
void BME280_SPIWriteReg(uint8_t spi_addr, uint8_t spi_data)
{
    BME280_Tx[0] = spi_addr & ~(1 << 7);
    BME280_Tx[1] = spi_data;

    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, false);

    SSIDataPut(SSI0_BASE, BME280_Tx[0]);
    while(SSIBusy(SSI0_BASE));
    SSIDataPut(SSI0_BASE, BME280_Tx[1]);
    while(SSIBusy(SSI0_BASE));

    SSIDataGet(SSI0_BASE, &BME280_Rx);
    SSIDataGet(SSI0_BASE, &BME280_Rx);

    GPIOPinWrite(GPIO_PORTA_BASE, GPIO_PIN_3, GPIO_PIN_3);
}

/*
 * Function to setup standby time parameter of the sensor
 *
 * Param: Timeout setting (available from predefined set)
 *
 * Return: Null
 *
 */
void BME280_SetStandBy(uint8_t timeout)
{
    static uint8_t ctrl_data;
    ctrl_data = BME280_SPIReadReg(BME280_CONFIG_REG);
    if(timeout > BME280_Standby_20ms)     timeout = BME280_Standby_1000ms;
    ctrl_data &= ~(BME280_Standby_Mask);
    ctrl_data |= (timeout << BME280_Standby_Pos);
    BME280_SPIWriteReg(BME280_CONFIG_REG, ctrl_data);
}

/*
 * Function to read currently set standby time parameter of the sensor
 *
 * Param: Null
 *
 * Return: Timeout setting (available from predefined set)
 *
 */
uint8_t BME280_GetStandBy(void)
{
    static uint8_t ctrl_data;
    ctrl_data = BME280_SPIReadReg(BME280_CONFIG_REG);
    ctrl_data &= (BME280_Standby_Mask);
    return (ctrl_data >> BME280_Standby_Pos);
}

/*
 * Function to setup operation mode parameter of the sensor
 *
 * Param: Mode setting (available from predefined set)
 *
 * Return: Null
 *
 */
void BME280_SetMode(uint8_t mode)
{
    static uint8_t ctrl_data;
    ctrl_data = BME280_SPIReadReg(BME280_CTRL_MEAS_REG);
    if((mode != BME280_MODE_SLEEP) && (mode != BME280_MODE_FORCED) && (mode != BME280_MODE_NORMAL))     mode = BME280_MODE_NORMAL;
    ctrl_data &= ~(BME280_MODE_MASK);
    ctrl_data |= (mode << BME280_MODE_Pos);
    BME280_SPIWriteReg(BME280_CTRL_MEAS_REG, ctrl_data);
}

/*
 * Function to read currently set operation mode parameter of the sensor
 *
 * Param: Null
 *
 * Return: Mode setting (available from predefined set)
 *
 */
uint8_t BME280_GetMode(void)
{
    static uint8_t ctrl_data;
    ctrl_data = BME280_SPIReadReg(BME280_CTRL_MEAS_REG);
    ctrl_data &= (BME280_MODE_MASK);
    return (ctrl_data >> BME280_MODE_Pos);
}

/*
 * Function to setup Humidity Oversampling parameter of the sensor
 *
 * Param: Oversampling Rate (available from predefined set)
 *
 * Return: Null
 *
 */
void BME280_SetHumOVS(uint8_t ovs)
{
    static uint8_t ctrl_data, orig_mode;
    orig_mode = BME280_GetMode();
    BME280_SetMode(BME280_MODE_SLEEP);
    ctrl_data = BME280_SPIReadReg(BME280_CTRL_HUMIDITY_REG);
    if(ovs > BME280_Hum_OVS16)    ovs = BME280_Hum_OVS16;
    ctrl_data &= ~(BME280_Hum_OVS_Mask);
    ctrl_data |= (ovs << BME280_Hum_OVS_Pos);
    BME280_SPIWriteReg(BME280_CTRL_HUMIDITY_REG, ctrl_data);
    BME280_SetMode(orig_mode);
}

/*
 * Function to setup Temperature Oversampling parameter of the sensor
 *
 * Param: Oversampling Rate (available from predefined set)
 *
 * Return: Null
 *
 */
void BME280_SetTempOVS(uint8_t ovs)
{
    static uint8_t ctrl_data, orig_mode;
    orig_mode = BME280_GetMode();
    BME280_SetMode(BME280_MODE_SLEEP);
    ctrl_data = BME280_SPIReadReg(BME280_CTRL_MEAS_REG);
    if(ovs > BME280_Temp_OVS16)    ovs = BME280_Temp_OVS16;
    ctrl_data &= ~(BME280_Temp_OVS_Mask);
    ctrl_data |= (ovs << BME280_Temp_OVS_Pos);
    BME280_SPIWriteReg(BME280_CTRL_MEAS_REG, ctrl_data);
    BME280_SetMode(orig_mode);
}

/*
 * Function to setup Pressure Oversampling parameter of the sensor
 *
 * Param: Oversampling Rate (available from predefined set)
 *
 * Return: Null
 *
 */
void BME280_SetPressureOVS(uint8_t ovs)
{
    static uint8_t ctrl_data, orig_mode;
    orig_mode = BME280_GetMode();
    BME280_SetMode(BME280_MODE_SLEEP);
    ctrl_data = BME280_SPIReadReg(BME280_CTRL_MEAS_REG);
    if(ovs > BME280_Pressure_OVS16)    ovs = BME280_Pressure_OVS16;
    ctrl_data &= ~(BME280_Pressure_OVS_Mask);
    ctrl_data |= (ovs << BME280_Pressure_OVS_Pos);
    BME280_SPIWriteReg(BME280_CTRL_MEAS_REG, ctrl_data);
    BME280_SetMode(orig_mode);
}

/*
 * Function to read all the calibration data from the sensor
 *
 * Param: Null
 *
 * Return: Null
 *
 */
void BME280_ReadAllCalib(void)
{
    //Reading all compensation data, range 0x88:A1, 0xE1:E7
    BME280_calib.dig_T1 = ((uint16_t)((BME280_SPIReadReg(BME280_DIG_T1_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_T1_LSB_REG)));
    BME280_calib.dig_T2 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_T2_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_T2_LSB_REG)));
    BME280_calib.dig_T3 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_T3_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_T3_LSB_REG)));

    BME280_calib.dig_P1 = ((uint16_t)((BME280_SPIReadReg(BME280_DIG_P1_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_P1_LSB_REG)));
    BME280_calib.dig_P2 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_P2_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_P2_LSB_REG)));
    BME280_calib.dig_P3 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_P3_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_P3_LSB_REG)));
    BME280_calib.dig_P4 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_P4_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_P4_LSB_REG)));
    BME280_calib.dig_P5 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_P5_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_P5_LSB_REG)));
    BME280_calib.dig_P6 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_P6_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_P6_LSB_REG)));
    BME280_calib.dig_P7 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_P7_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_P7_LSB_REG)));
    BME280_calib.dig_P8 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_P8_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_P8_LSB_REG)));
    BME280_calib.dig_P9 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_P9_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_P9_LSB_REG)));

    BME280_calib.dig_H1 = ((uint8_t)(BME280_SPIReadReg(BME280_DIG_H1_REG)));
    BME280_calib.dig_H2 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_H2_MSB_REG) << 8) + BME280_SPIReadReg(BME280_DIG_H2_LSB_REG)));
    BME280_calib.dig_H3 = ((uint8_t)(BME280_SPIReadReg(BME280_DIG_H3_REG)));
    BME280_calib.dig_H4 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_H4_MSB_REG) << 4) + (BME280_SPIReadReg(BME280_DIG_H4_LSB_REG) & 0x0F)));
    BME280_calib.dig_H5 = ((int16_t)((BME280_SPIReadReg(BME280_DIG_H5_MSB_REG) << 4) + ((BME280_SPIReadReg(BME280_DIG_H4_LSB_REG) >> 4) & 0x0F)));
    BME280_calib.dig_H6 = ((int8_t)BME280_SPIReadReg(BME280_DIG_H6_REG));
}

/*
 * Function to read all 8 data registers of the sensor (from Pressure MSB to Humidity LSB)
 *
 * Param: Null
 *
 * Return: Null
 *
 */
void BME280_ReadAllDataReg(void)
{
    BME280_SPIReadMultiReg(&BME280_Data[0], BME280_PRESSURE_MSB_REG, BME280_DataRegNos);
}

/*
 * Function to calculate the pressure in Pascals
 *
 * Param: float pointer to the variable where the result should be stored
 *
 * Return: Null
 *
 */
void BME280_GetPressure(float *var_p)
{
    static int32_t adc_pressure;
    static int64_t var1, var2, pressure_fine;

    adc_pressure = ((uint32_t)BME280_Data[BME280_Pressure_MSB_Pos] << 12) |
            ((uint32_t)BME280_Data[BME280_Pressure_LSB_Pos] << 4) | ((BME280_Data[BME280_Pressure_XLSB_Pos] >> 4) & 0x0F);

    var1 = ((int64_t)BME280_TempFine) - 128000;
    var2 = var1 * var1 * (int64_t)BME280_calib.dig_P6;
    var2 = var2 + ((var1 * (int64_t)BME280_calib.dig_P5)<<17);
    var2 = var2 + (((int64_t)BME280_calib.dig_P4)<<35);
    var1 = ((var1 * var1 * (int64_t)BME280_calib.dig_P3)>>8) + ((var1 * (int64_t)BME280_calib.dig_P2)<<12);
    var1 = (((((int64_t)1)<<47)+var1))*((int64_t)BME280_calib.dig_P1)>>33;
    if (var1 == 0)
    {
        *var_p = -1;
    }
    else
    {
        pressure_fine = 1048576 - adc_pressure;
        pressure_fine = (((pressure_fine<<31) - var2)*3125)/var1;
        var1 = (((int64_t)BME280_calib.dig_P9) * (pressure_fine>>13) * (pressure_fine>>13)) >> 25;
        var2 = (((int64_t)BME280_calib.dig_P8) * pressure_fine) >> 19;
        pressure_fine = ((pressure_fine + var1 + var2) >> 8) + (((int64_t)BME280_calib.dig_P7)<<4);

        *var_p = (float)(pressure_fine / 256.0);
    }
}

/*
 * Function to calculate the temperature in degree Celcius
 *
 * Param: float pointer to the variable where the result should be stored
 *
 * Return: Null
 *
 */
void BME280_GetTemp(float *var_t)
{
    static int32_t adc_temp;
    static int64_t var1, var2;


    adc_temp = ((uint32_t)BME280_Data[BME280_Temp_MSB_Pos] << 12) |
            ((uint32_t)BME280_Data[BME280_Temp_LSB_Pos] << 4) | ((BME280_Data[BME280_Temp_XLSB_Pos] >> 4) & 0x0F);

    //By datasheet, calibrate
    var1 = ((((adc_temp>>3) - ((int32_t)BME280_calib.dig_T1<<1))) * ((int32_t)BME280_calib.dig_T2)) >> 11;
    var2 = (((((adc_temp>>4) - ((int32_t)BME280_calib.dig_T1)) * ((adc_temp>>4) - ((int32_t)BME280_calib.dig_T1))) >> 12) * ((int32_t)BME280_calib.dig_T3)) >> 14;
    BME280_TempFine = var1 + var2;
    *var_t = (BME280_TempFine * 5 + 128) >> 8;
    *var_t /= 100;
}

/*
 * Function to calculate the relative humidity in percentages
 *
 * Param: float pointer to the variable where the result should be stored
 *
 * Return: Null
 *
 */
void BME280_GetHum(float *var_h)
{
    static int32_t adc_hum;
    static int64_t var1;

    adc_hum = ((uint32_t)BME280_Data[BME280_Hum_MSB_Pos] << 8) | ((uint32_t)BME280_Data[BME280_Hum_LSB_Pos]);

    var1 = (BME280_TempFine - ((int32_t)76800));
    var1 = (((((adc_hum << 14) - (((int32_t)BME280_calib.dig_H4) << 20) - (((int32_t)BME280_calib.dig_H5) * var1)) +
    ((int32_t)16384)) >> 15) * (((((((var1 * ((int32_t)BME280_calib.dig_H6)) >> 10) * (((var1 * ((int32_t)BME280_calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) + ((int32_t)2097152)) *
    ((int32_t)BME280_calib.dig_H2) + 8192) >> 14));
    var1 = (var1 - (((((var1 >> 15) * (var1 >> 15)) >> 7) * ((int32_t)BME280_calib.dig_H1)) >> 4));
    var1 = (var1 < 0 ? 0 : var1);
    var1 = (var1 > 419430400 ? 419430400 : var1);

    *var_h = (float)((var1>>12) / 1024.0);
}

/*
 * Function to set the preferred initial parameters of the sensor
 *
 * Param: Null
 *
 * Return: Boolean variable indicating whether the setup was successful or not
 * (True: Success, False: Failure)
 *
 */
bool BME280_SensorSetup(void)
{
    if(BME280_SPIReadReg(BME280_CHIP_ID_REG) == BME280_DevID)
    {
        #if BME280_DEBUG_PRINTF

            Log_Msg(T_BME, "INFO", "BME280 Device ID Verified", LOCAL_ONLY);
        #endif
    }
    else
    {
        #if BME280_DEBUG_PRINTF

            Log_Msg(T_BME, "ERROR", "BME280 Device ID Verification Failed", LOCAL_ONLY);
        #endif
        return true;
    }

    BME280_ReadAllCalib();

    BME280_SetStandBy(BME280_Standby_20ms);
    if(BME280_GetStandBy() == BME280_Standby_20ms)
    {
        #if BME280_DEBUG_PRINTF
                Log_Msg(T_BME, "INFO", "BME280 Standby set to 20ms", LOCAL_ONLY);
        #endif
    }
    else
    {
        #if BME280_DEBUG_PRINTF
                Log_Msg(T_BME, "ERROR", "BME280 Standby Setting Failed", LOCAL_ONLY);
        #endif
        return true;
    }

    BME280_SetMode(BME280_MODE_NORMAL);
    if(BME280_GetMode() == BME280_MODE_NORMAL)
    {
        #if BME280_DEBUG_PRINTF
           //     BME280_Print("\nBME280 Mode Set to Normal");
        #endif
    }
    else
    {
        #if BME280_DEBUG_PRINTF
             //   BME280_Print("\nBME280 Mode Setting Failed");
        #endif
        return true;
    }

    BME280_SetHumOVS(BME280_Hum_OVS1);
    #if BME280_DEBUG_PRINTF
       //     BME280_Print("\nBME280 Humidity Oversampling Set to 1x");
    #endif

    BME280_SetTempOVS(BME280_Temp_OVS1);
    #if BME280_DEBUG_PRINTF
        //   BME280_Print("\nBME280 Temperature Oversampling Set to 1x");
    #endif

    BME280_SetPressureOVS(BME280_Pressure_OVS1);
    #if BME280_DEBUG_PRINTF
      //      BME280_Print("\nBME280 Pressure Oversampling Set to 1x");
    #endif

    return false;
}

/*
 * Function to check whether the sensor is online or not
 * by simply reading the ID of the sensor. Updates the
 * proper varialbes if there is an error.
 *
 * Param: Null
 *
 * Return: Null
 *
 */
void BME280_TestSensor(void)
{
    BME280_Error = false;
    if(BME280_SPIReadReg(BME280_CHIP_ID_REG) != BME280_DevID)
    {
        #if BME280_DEBUG_PRINTF
        //    BME280_Print("\nBME280 Device ID Verification Failed");
        #endif
        BME280_Error = true;
        #if     (BME280_Retry_Mode == BME280_Limited)
            BME280_Retries = BME280_Max_Retries;
        #endif
        #if     BME280_DEBUG_PRINTF
         //   BME280_Print("\nBME280 is Offline");
        #endif
    }
}
/*
 * BBComm_Task.c
 *
 *  Created on: Apr 15, 2019
 *      Author:  Author: Khalid AlAwadhi
 */
#include "BBComm_Task.h"
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>

//TivaWare includes
#include "driverlib/uart.h"
#include "inc/hw_memmap.h"

//FreeRTOS includes
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"

//My includes
#include "Global_Defines.h"
#include "Master_Functions.h"
#include "My_UART.h"

/* Global Variables */
extern QueueHandle_t xQueue_TXStruct;
extern bool POLL_RX;
extern QueueHandle_t xQueue_KEStruct;
extern QueueHandle_t xQueue_LCStruct;
extern QueueHandle_t xQueue_OIStruct;


uint8_t BBComm_TaskInit()
{
    //Create task, if it fails return 1, else 0
    if( xTaskCreate(BBComm_Task,					/* The function that implements the task */
			   (const portCHAR *)"BBComm",			/* The text name assigned to the task - for debug only as it is not used by the kernel */
               ((configMINIMAL_STACK_SIZE) * 25),	/* The size of the stack to allocate to the task */
			   NULL,								/* The parameter passed to the task */
			   PRIORITY_BBCOMM_TASK, 				/* The priority assigned to the task */
			   NULL)								/* The task handle is not required, so NULL is passed */
    			!= pdTRUE
      )
      {
    	return 1;
      }

	return 0;
}



void BBComm_Task(void *pvParameters)
{
	/* Create a queue capable of containing 50 structs */
	xQueue_TXStruct = xQueueCreate(25,  MAX_STRUCT_SIZE);

	if( xQueue_TXStruct == NULL )
	{
		/* Queue was not created and must not be used. */
		Log_Msg(T_BBComm, "FATAL", "Could not create xQueue_TXStruct!", LOCAL_ONLY);
	}
	else
	{
		Log_Msg(T_BBComm, "INFO", "Created xQueue_TXStruct successfully!", LOCAL_ONLY);
	}

	/* Buffer that will store received structs */
	uint8_t RX_Struct_Buffer[MAX_STRUCT_SIZE];

	/* Buffer that will store structs to be TXed */
	uint8_t TX_Struct_Buffer[MAX_STRUCT_SIZE];

	/* Init UART1 - Used to talk to the BeagleBone via Bluetooth */
	Init_UARTx(UART1, SYSTEM_CLOCK, 9600, true);

	/* Delay before next poll */
	//const TickType_t xDelay = 10 / portTICK_PERIOD_MS;

	int16_t RX_Index = 0;
	uint32_t RX_Timeout = 0;
	bool RX_Error = false;

	while(1)
	{
		/* If we need to RX something: */
		if(POLL_RX)
		{
			Log_Msg(T_BBComm, "DEBUG", "POLL RX STARTED!", LOCAL_ONLY);

			taskENTER_CRITICAL();

			/* Reset */
			RX_Index = 0;
			RX_Timeout = 0;
			RX_Error = false;

			/* Create an array of bytes to fit the given struct */
			uint8_t RX_Struct_Buffer[MAX_STRUCT_SIZE];

			/* Keep adding to the buffer until we get a "!" */
			do
			{
				/* Send confirmation back */
		//		UART_Putchar_n(UART1, CONFIRM_CMD);

				/* If char is available */
				if(UARTCharsAvail(UART1_BASE) == true)
				{
					/* Block and get byte */
					RX_Struct_Buffer[RX_Index] = UARTCharGet(UART1_BASE);
					/* RX was successful, increment index */
					RX_Index++;
				}
				else
				{
					RX_Timeout++;
				}

				if(RX_Timeout == RX_TIMEOUT_VALUE)
				{
					RX_Error = true;
					break;
				}

			} while ( RX_Struct_Buffer[RX_Index-1] != END_CMD_CHAR );

			taskEXIT_CRITICAL();

			if(RX_Error)
			{
				Log_Msg(T_BBComm, "ERROR", "RX timeout! Discarding data...", LOCAL_ONLY);
			}
			else
			{
				RX_Struct_Buffer[RX_Index-1] = '\x00';

			//	Log_Msg(T_BBComm, "DEBUG", "GOT STRUCT", LOCAL_ONLY);

				Decode_StructBuffer(RX_Struct_Buffer);
			}
			POLL_RX = false;
		}
		else
		{
			/* Else, check if we need to TX something */
			if( xQueue_TXStruct != 0 )
			{
				/* Block for 10 ticks if a message (struct buffer) is not immediately available */
				if( xQueueReceive( xQueue_TXStruct, TX_Struct_Buffer, ( TickType_t ) 10 ) )
				{

//					if(TX_Struct_Buffer[0] == 4)
//					{
//						char prt[50];
//						snprintf(prt, 50, "\nEK Struct is:%x %x %x %x %x %x %x %x", TX_Struct_Buffer[0], TX_Struct_Buffer[1],
//								 TX_Struct_Buffer[2], TX_Struct_Buffer[3], TX_Struct_Buffer[4], TX_Struct_Buffer[5],
//								 TX_Struct_Buffer[6], TX_Struct_Buffer[7]);
//						Log_Msg(T_BBComm, "DEBUG", prt, LOCAL_ONLY);
//					}

//					if(TX_Struct_Buffer[0] == 6)
//					{
//
//						uint8_t i;
//						for(i = 0; i < sizeof(LC_T2B_Struct); i++)
//						{
//							char prt[50];
//							snprintf(prt, 50, "TX_Struct_Buffer[%u] = %u | %c\n", i, TX_Struct_Buffer[i], TX_Struct_Buffer[i]);
//							Log_Msg(T_BBComm, "DEBUG", prt, LOCAL_ONLY);
//						}
//					}

					UART_Putchar_n(UART1, START_CMD);                        //Send Start CMD to BB

					Send_StructBuffer_UARTx(UART1, TX_Struct_Buffer);        //Send structure to BB

					UART_Putchar_n(UART1, END_CMD);                          //Send End CMD to BB
				}
			}
		}

		/* Delay for 10 mS */
		//vTaskDelay(xDelay);
		taskYIELD();
	}
}



void Decode_StructBuffer(uint8_t* StructToDecode)
{
	/* Create the needed structs that will store buffer contents */
	KE_B2T_Struct KE_B2T_ToSend;
	LC_B2T_Struct LC_B2T_ToSend;
	OI_B2T_Struct OI_B2T_ToSend;

	/* Get what structure it is, based on the first byte */
	switch( StructToDecode[0] )
	{
		case LogMsg_Struct_ID:
			Log_Msg(T_BBComm, "ERROR", "How did you even send a LogMsg_Struct back here to Tiva!?", LOCAL_ONLY);
			break;

		case KE_B2T_Struct_ID:
		//	Log_Msg(T_BBComm, "DEBUG", "GOT KE_B2T_Struct!", LOCAL_ONLY);

			/* Copy the contents of the buffer to the struct */
			memcpy(&KE_B2T_ToSend , StructToDecode, sizeof(KE_B2T_Struct));

			/* Send Struct to KeypadEpaper Task xQueue - Wait for 10 ticks if xQueue is full */
			if ( (xQueueSend( xQueue_KEStruct, &KE_B2T_ToSend, ( TickType_t ) 10 ) ) != pdTRUE)
			{
				Log_Msg(T_BBComm, "ERROR", "Could not send KE_B2T_Struct to xQueue_KEStruct", LOCAL_ONLY);
			}
			break;

		case LC_B2T_Struct_ID:
		//	Log_Msg(T_BBComm, "DEBUG", "GOT LC_B2T_Struct!", LOCAL_ONLY);

			/* Copy the contents of the buffer to the struct */
			memcpy(&LC_B2T_ToSend , StructToDecode, sizeof(LC_B2T_Struct));

			/* Send Struct to LoadCell Task xQueue - Wait for 10 ticks if xQueue is full */
			if ( (xQueueSend( xQueue_LCStruct, &LC_B2T_ToSend, ( TickType_t ) 10 ) ) != pdTRUE)
			{
				Log_Msg(T_BBComm, "ERROR", "Could not send LC_B2T_Struct to xQueue_LCStruct", LOCAL_ONLY);
			}
			break;

		case OI_B2T_Struct_ID:
			Log_Msg(T_BBComm, "DEBUG", "GOT OI_B2T_Struct!", LOCAL_ONLY);

			/* Copy the contents of the buffer to the struct */
			memcpy(&OI_B2T_ToSend , StructToDecode, sizeof(OI_B2T_Struct));

			/* Send Struct to Outputs Task xQueue - Wait for 10 ticks if xQueue is full */
			if ( (xQueueSend( xQueue_OIStruct, &OI_B2T_ToSend, ( TickType_t ) 10 ) ) != pdTRUE)
			{
				Log_Msg(T_BBComm, "ERROR", "Could not send OI_B2T_Struct to xQueue_OIStruct", LOCAL_ONLY);
			}
			break;

		default:
			Log_Msg(T_BBComm, "ERROR", "Decode_StructBuffer() aborted - unknown structure!", LOCAL_ONLY);
			return;
	}
}

